# 战略资产配置助手 - 开发计划

本文档根据需求概述了构建此 Android 应用程序所需的技术栈和分步计划。

## IDE 使用与本地测试

- **本地测试:** 所有开发步骤都将首先在 **Android 模拟器** 上进行测试。你可以通过 **Android Studio 的 AVD Manager** 来创建和管理模拟器，无需实体手机即可在电脑上运行和调试应用。
- **Cursor:** 作为所有编码、重构和 AI 辅助开发的主要 IDE。
- **Android Studio:** 用于其专业工具可提供优势的特定任务，尤其是**管理模拟器**和使用**可视化调试工具**。

---

## 技术栈

- **语言:** **Kotlin**
- **UI 工具包:** **Jetpack Compose**
- **架构:** **MVVM** 结合整洁架构原则
- **异步编程:** **Kotlin Coroutines & Flow**
- **依赖注入:** **Hilt**
- **数据库:** **Room**
- **网络:** **Retrofit & OkHttp**
- **数据序列化:** **Kotlinx.serialization**
- **后台任务:** **WorkManager**
- **导航:** **Navigation Compose**

---

## MVP 迭代开发计划

我们将遵循最小可用原则，确保每一步都能产出一个可在模拟器上运行和验证的程序。

### 里程碑 1: 显示静态模拟数据的基本应用

**目标:** 创建一个能够启动并显示硬编码资产列表的应用。

- [x] **1.1. 初始化项目:** 创建一个空 Android 项目。
	- [x] 验证项目初始化，跑通Android Studio里的编译->调试流程
		- 成功：![](../pic/2025-08-23-14-33-19.png)
	- [x] 确认是否包含Jetpack Compose
- [x] **1.2. 定义核心数据模型:** 仅创建 `Asset` 数据类。
- [x] **1.3. 创建UI和ViewModel:**
    - [x] 创建一个 `PortfolioViewModel`。
    - [x] 在 ViewModel 中创建一个硬编码的 `Asset` 列表（例如2-3个样本资产）。
    - [x] 创建一个主屏幕 Composable，使用 `LazyColumn` 从 ViewModel 获取并显示这个静态列表。
- [x] **1.4. 运行应用:** 在 Android 模拟器上编译并运行应用，验证列表是否正确显示。
- [x] 迭代改进
	- [x] ID改为使用UUID
- [x] 环境搭建
	- [x] 在cursor里实现编译，方便ai排查编译报错
    - [x] 在cursor里启动程序，因为开启android studio的话build目录的权限就会被锁上，导致没法在cursor里编译了
        - [x] avd启动
        - [x] 安装apk到avd上
        - [x] 启动应用

### 里程碑 2: 本地数据持久化与展示

**目标:** 将资产数据从硬编码迁移到本地数据库，并从数据库加载显示。

- [x] **2.1. 集成 Room 数据库:**
    - [x] 添加 Room 依赖。
    - 数据库设计：多表方案
        - **设计思路**：采用多表设计，将不同类型的持仓信息分别存储在独立的表中，通过外键关联
        - **表结构**：
            - `assets`表（主表）：id(UUID), name, type, targetWeight, code, shares, value, lastUpdateTime
            - `portfolio`表：cash(Double)
        - **优势**：数据规范化、类型安全、扩展性好、查询效率高、数据完整性保证
        - **映射关系**：Repository负责在Domain对象与Room Entity之间转换
    - [x] 创建Entity,DAO和数据库类
- [x] **2.2. 创建数据仓库:** 实现 `PortfolioRepository`，用于从 Room 数据库中读取资产数据。
- [x] **2.3. 更新 ViewModel:** 修改 `PortfolioViewModel`，通过仓库从数据库异步加载资产列表（使用 `Flow`）。
- [x] **2.4. 数据库预填充:** 实现一个一次性逻辑，在数据库首次创建时，向其中插入一些初始的样本数据。
- [x] **2.5. 运行与验证:** 运行应用，确认显示的资产数据是从数据库加载的。可以使用 Android Studio 的 **Database Inspector** 查看数据库内容。

### 里程碑 3: 资产的增删改功能

**目标:** 实现用户手动添加、编辑和删除资产的功能。

- [x] **3.1. 创建导航:** 添加 Navigation Compose 依赖，设置主列表页和添加/编辑页之间的导航。
- [x] **3.2. 创建添加/编辑屏幕:**
    - [x] 设计一个表单 UI，用于输入资产信息。
    - [x] 创建对应的 `AddEditAssetViewModel`
        - 用于`AddEditAssetScreen`的临时数据存储，实现和UI的分离
        - 当保存/取消编辑操作后，该view model里的数据就会被应用掉然后销毁
- [x] **3.3. 实现数据操作:**
    - [x] 在 Repository和 DAO 中添加 `insert`、`update`、`delete` 方法，提供对数据库中Asset增删改的接口
    - [x] 在 ViewModel 中调用这些方法来保存或删除资产。
- [x] **3.4. 运行与验证:** 运行应用，尝试添加一个新资产，编辑一个现有资产，然后删除它，确认所有操作都正确反映在主屏幕和数据库中。
- [x] 删除资产

### 里程碑 3.5: 集成 Hilt 依赖注入框架

**目标:** 重构现有代码库，引入 Hilt 以实现依赖项的自动化管理，为后续网络模块等功能的开发奠定架构基础。

- [x] **3.5.1. 添加 Hilt 依赖和插件:**
    - [x] 在项目根目录和 app 模块的 `build.gradle.kts` 文件中添加 Hilt 插件。
    - [x] 在 app 模块的 `build.gradle.kts` 文件中添加 Hilt 相关依赖。
- [x] **3.5.2. 配置 Application 类:**
    - [x] 创建一个自定义的 `Application` 类 (例如 `MainApplication.kt`)。
    - [x] 为该类添加 `@HiltAndroidApp` 注解。
    - [x] 在 `AndroidManifest.xml` 中将 application-name 指向这个新创建的类。
- [x] **3.5.3. 迁移 Activity 和 ViewModel:**
    - [x] 为 `MainActivity` 添加 `@AndroidEntryPoint` 注解。
    - [x] 为 `PortfolioViewModel` 和 `AddEditAssetViewModel` 添加 `@HiltViewModel` 注解，并用 `@Inject` 标注其构造函数。
    - [x] 更新 UI 代码，使用 `hiltViewModel()` 来获取 ViewModel 实例。
- [x] **3.5.4. 创建 Hilt 模块并迁移数据层:**
    - [x] 创建一个 Hilt 模块 (例如 `DatabaseModule.kt`) 来提供数据库实例 (`AppDatabase`) 和 DAO (`AssetDao`, `PortfolioDao`)。
    - [x] 为 `PortfolioRepository` 的构造函数添加 `@Inject` 注解，让 Hilt 负责其创建和依赖注入。
- [x] **3.5.5. 运行与验证:**
    - [x] 编译并运行应用，确保所有功能（列表显示、增、删、改）在重构后依然正常工作。

### 里程碑 4: 集成网络请求与手动刷新

**目标:** 引入网络功能，通过手动操作从远程 API 获取数据并更新资产市值。

- [x] **4.1. 集成 Retrofit:** 添加 Retrofit 和 Kotlinx.serialization 依赖，并配置网络客户端。
    - [x] 添加依赖
    - [x] 创建 Hilt 网络模块 (NetworkModule)
    - [x] 在 NetworkModule 中配置并提供 OkHttpClient 实例 (用于日志记录等)
    - [x] 在 NetworkModule 中配置并提供 Retrofit 实例 (设置基础URL和序列化转换器)
- [x] **4.2. 定义空的API接口:** 假想有一个金融数据API，为其创建一个简单的 Retrofit 接口（例如，根据资产代码查询价格）。
- [x] **4.3. 添加刷新按钮:** 在主屏幕上添加一个“手动刷新”按钮。
- [x] **4.4. 实现刷新逻辑:**
    - [x] 创建 `UpdateMarketDataUseCase`。
    - [x] 当点击刷新按钮时，遍历数据库中的所有资产，调用 API 获取最新价格，然后更新数据库中对应资产的市值。
- [x] **4.5. 实现金融数据API:**
    - [x] 调研适合A股的金融数据API
        * AShare：底层爬的新浪和腾讯的接口
            * 先试试这个
        * Tushare：得掏钱
    - [x] 增加一个用于测试API连通性的界面，它让用户手动输入要输给API的参数，然后把api返回的内容原原本本地打印到屏幕上
        * 该界面的入口在AssetListScreen的左上角小按钮
    - [x] 测试接口能否正常运作
    - [x] 正确实现`UpdateMarketDataUseCase`
- [x] **4.6. 运行与验证:** 运行应用，点击刷新按钮，观察资产市值是否成功更新。




### 里程碑 5: 仪表盘与分析: 在主屏幕计算并显示资产占比、偏离度等分析数据。
- [x] 5.1. 扩展ViewModel计算逻辑 
    - 在 `PortfolioViewModel` 中增加计算逻辑，用于计算总市值、以及各项资产的：
        * 占总资产的占比
        * 偏离目标占比多少百分比
        * 目标占比下的市场价值
        * 偏离目标占比多少市场价值
- [x] 5.2. 改造`AssetListScreen`：在资产列表中为每一项资产增加显示上述分析数据


### 里程碑 6: 后台自动刷新: 使用 `WorkManager` 实现后台定时更新市场数据。
- [x] 6.1. 集成 WorkManager: 添加 `WorkManager` 依赖。
- [x] 6.2. 创建后台任务: 实现一个 `MarketDataSyncWorker`，该 Worker 复用 `UpdateMarketDataUseCase` 来在后台执行数据更新逻辑。
- [x] 6.3. 调度任务
    - [x] 在 `MainApplication` 中，配置并调度一个周期性的 `PeriodicWorkRequest`
    - [x] 在AssetListScreen右上角（刷新按钮的左边）增加一个临时的checkbox，用来控制是否开启自动刷新
    - 目前先让它每隔15分钟执行一次
- [x] 6.4. 验证: 使用 Android Studio 的 `App Inspection` 或 `Logcat` 来验证后台任务是否按预期执行和完成。

### 里程碑 7: 交易管理: 实现交易记录的查看和手动添加功能。
- [x] 7.1. 创建交易数据库:
    - [x] 设计并创建 `TransactionEntity` 用于存储交易记录 (包括资产ID、交易类型、份额、价格、费用、时间等)。
    - [x] 创建对应的 `TransactionDao`。
    - [x] 在 `AppDatabase` 中注册新表
- [x] 7.2. 创建交易的界面:
    - [x] 创建 `TransactionViewModel` 管理交易列表界面的状态和业务逻辑。
    - [x] 创建 `TransactionListScreen`，用于显示所有历史交易记录。
    - [x] 创建 `AddEditTransactionViewModel` 管理编辑交易界面的状态和业务逻辑。
    - [x] 创建 `AddEditTransactionScreen`，正确建立和`TransactionListScreen`之间的导航
        * 它与`AddEditAssetScreen`应该类似
    - [x] 填充`AddEditTransactionScreen`，提供表单让用户可以手动录入一笔新的交易或编辑已有交易或删除现有交易。
- [x] 7.3. 将交易和资产关联起来，实现业务逻辑:
    - [x] 扩展 `PortfolioRepository`，添加 `addTransaction` 等方法。在该方法内，需要以原子方式（数据库事务）完成以下操作：插入一条新的交易、更新对应资产的持有份额、更新投资组合的现金数量。
        * 编辑交易可以被视作删除一条现有交易，再新增一条交易

### 里程碑 8: 导入/导出与设置: 实现 JSON 导入/导出功能和应用设置界面。
- [x] 8.1. 创建设置界面:
    - [x] 创建一个 `SettingsScreen` Composable。
    - [x] 添加从主界面到设置界面的导航。
- [x] 8.2. 实现数据导入/导出:
    - [x] 设计好用于导入/导出的 JSON 数据结构。
    - [x] 在 `SettingsScreen` 添加“导入”和“导出”按钮。
    - [x] 实现导出逻辑：从数据库读取所有资产和投资组合数据，序列化为 JSON，直接存入系统剪贴板（弹出提示框告知用户这件事）
    - [x] 实现导入逻辑：弹出一个输入框让用户输入json文件
- [x] 8.3. 实现后台刷新频率设置:
    - [x] 集成 `DataStore` 用于持久化存储用户设置。
    - [x] 在 `SettingsScreen` 中添加一个选项，允许用户选择后台数据刷新的频率。
    - [x] 修改里程碑 6 中的任务调度逻辑，使其能够根据用户在设置中选择的频率来动态地调度后台任务。


### 里程碑 9: 交易机会提醒: 实现交易规则判断和系统通知功能。

**目标:** 实现一个系统，能够根据预设规则自动检测交易机会，并通过系统通知提醒用户。

- [x] **9.1. 定义数据模型与数据库:**
    - [x] 创建 `TradingOpportunity` domain 对象和对应的 `TradingOpportunityEntity`。
    - [x] 设计 `TradingOpportunity` 表结构，它包含以下信息：
        * 交易记录里有的所有信息
        * 触发理由，这是个字符串，是用来给用户看的
    - [x] 创建 `TradingOpportunityDao` 并更新 `AppDatabase`。
- [x] **9.2. 设计和实现交易规则引擎:**
    - [x] 创建一个 `CheckTradingOpportunitiesUseCase`，用于封装检查逻辑：目前固定生成一条对第一个资产的交易机会即可
- [x] **9.3. 创建交易机会界面:**
    - [x] 创建 `TradingOpportunityViewModel` 和 `TradingOpportunityListScreen`。
    - [x] 在 `AssetListScreen` 添加一个入口导航至新界面。
    - [x] `TradingOpportunityListScreen` 负责从数据库中读取并展示所有交易机会。
    - [x] 界面上应提供“手动检查”和“一键清空”按钮。
- [x] **9.4. 将机会转化为交易:**
    - [x] 在每个交易机会旁边提供一个“执行”或“转换为交易”的按钮。
    - [x] 点击后，导航至 `AddEditTransactionScreen`，并根据交易机会的数据预先填好表单。
    - [x] 成功创建交易后，对应的交易机会应被删除。
- [x] **9.5. 实现后台检查与系统通知:**
    - [x] 重构现有的`MarketDataSyncWorker`，让它多出来发现交易机会的功能
    - [x] 当后台任务发现新的交易机会时，向数据库中插入这些机会，并触发一个系统通知。
    - [x] 点击通知后应能跳转到 `TradingOpportunityListScreen`。



### 里程碑 10：实际使用与打包

* [x] 处理好数据库迁移
* [x] 打包安装到我的手机上
